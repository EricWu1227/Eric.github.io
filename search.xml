<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[外观设计模式]]></title>
    <url>%2F2017%2F06%2F12%2F%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[由于目前多个项目中大量使用外观设计模式,故对此设计模式做一总结外观模式（Facade），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。外观模式包含如下两个角色：(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql在存在主键唯一索引的情况下怎么增加唯一联合索引]]></title>
    <url>%2F2017%2F05%2F31%2Fmysql%E5%9C%A8%E5%AD%98%E5%9C%A8%E4%B8%BB%E9%94%AE%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%80%8E%E4%B9%88%E5%A2%9E%E5%8A%A0%E5%94%AF%E4%B8%80%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[我们需要为以前的表 创建这个索引,有可能以前的数据中存在重复的记录 那怎么办呢?alter ignore table quality_issue_info add unique index biz_id(issue_channel,invoke_id);它会删除重复的记录（别怕，会保留一条），然后建立唯一索引，高效而且人性化.]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2017%2F05%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好,欢迎来到我的个人技术博客!]]></content>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>