<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[groovy安全导航符]]></title>
    <url>%2F2017%2F06%2F16%2Fgroovy%E5%AE%89%E5%85%A8%E5%AF%BC%E8%88%AA%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[groovy提供了?. 安全导航操作符来简化对空指针的处理,避免抛出空指针异常,以达到减少噪音,节省开发者精力的目的 示例代码def foo(str){ //if (str != null) {str.reverse()} str?.reverse()}println foo(‘evil’)println foo(null) 输出结果:live null]]></content>
  </entry>
  <entry>
    <title><![CDATA[groovy学习笔记]]></title>
    <url>%2F2017%2F06%2F13%2Fgroovy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[groovy提供以下三种循环方法class WaysToLoop { void hello(){ 0.upto(2){println”$it”} println(“================”) 3.times { println(“$it”)} println(“================”) 0.step(10,2){ println(“$it”)} 3.times {print(‘ho’)} println ‘hello’ }}其中$it代表循环时的索引值]]></content>
  </entry>
  <entry>
    <title><![CDATA[外观设计模式]]></title>
    <url>%2F2017%2F06%2F12%2F%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[由于目前多个项目中大量使用外观设计模式,故对此设计模式做一总结外观模式（Facade），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。外观模式包含如下两个角色：(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql创建索引相关]]></title>
    <url>%2F2017%2F05%2F31%2Fmysql%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[PRIMARY KEY（主键索引）ALTER TABLE table_name ADD PRIMARY KEY (column_name)UNIQUE(唯一索引)ALTER TABLE table_name ADD UNIQUE (column_name)INDEX(普通索引)ALTER TABLE table_name ADD INDEX index_name (column_name)多列索引,列值的组合必须唯一ALTER TABLE table_name ADD INDEX index_name (column1_name,column2_name,column3_name)查看索引SHOW INDEX FROM table_name我们需要为以前的表 创建这个索引,有可能以前的数据中存在重复的记录 那怎么办呢?alter ignore table table_name add unique index index_name(column1_name,column2_name);它会删除重复的记录（别怕，会保留一条），然后建立唯一索引，高效而且人性化.]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2017%2F05%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好,欢迎来到我的个人技术博客!]]></content>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>