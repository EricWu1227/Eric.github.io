<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于字符串内存管理策略的问题]]></title>
    <url>%2F2017%2F07%2F04%2F%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[转自知乎大V姚冬 几十年前 在C和Pascal的时代，就有字符串存储形式 是 \0 结尾还是 长度+内容的争论，这个问题严重影响了API的设计，内存的管理，甚至程序架构。字符串是一种非常常用的 生命周期通常很短的对象，而且它的size是不固定的，长度为 1 或 1GB都有可能，导致内存管理非常麻烦复杂。用长度+内容表示，每个串都要额外付出4个字节，用\0结尾吧，算长度就很麻烦，万一结尾忘了\0就要崩溃，选哪个好字符串的长度放哪里，放到起始指针的位置，还是起始指针的前面如果放前面，那么字符串起始指针和内存块起始不一致怎么解决字符串拼接的时候把源串复制到目标串结尾，那么目标串剩余内存不够怎么办，重新分配要多一次赋值，频繁拼接性能有问题怎么办函数返回值如果是字符串，那么这个串是调用者分配内存还是被调用者分配，谁来负责释放。如果调用者分配，那么调用者怎么知道字符串将有多长。频繁分配释放大小各异的字符串，会不会导致内存碎片化对于小字符串是分配在堆上还是栈上怎么把常量串和变量串分别处理如果设计面向对象的字符串，字符串加法怎么定义，是在原来对象上加，还是生成一个新对象如果每加一次都生成新对象会不会导致构造析构太频繁如果是托管语言会不会太频繁GC要不要设计单独的辅助类来解决字符串拼接问题那这个辅助类怎么设计，要不要考虑线程安全如果考虑线程安全的话，怎么兼顾性能]]></content>
  </entry>
  <entry>
    <title><![CDATA[groovy中的javaBean]]></title>
    <url>%2F2017%2F07%2F03%2Fgroovy%E4%B8%AD%E7%9A%84javaBean%2F</url>
    <content type="text"><![CDATA[class Car { def miles = 0 final year Car(theYear) { year = theYear } }Car car = new Car(2008)println “Year: $car.year”println “Miles: $car.miles”println ‘Setting miles’car.miles = 25println “Miles: $car.miles” 当代码中调用miles时,其实并非引用一个字段,而是调用该属性的访问器.要把属性设置为只读的,需要使用final来声明该属性.在这种情况下,groovy会为该属性提供一个访问器,但不提供更改器.groovy的实现不区分public,private和protected.如果想把变量设置为私有的,需要实现一个拒绝任何修改的更改器.示例代码如下 class Car2 { final year private miles = 0 Car2(theYear) { year = theYear } def getMiles() { println &quot;getMiles called&quot; miles } private void setMiles(miles) { throw new IllegalAccessException(&quot;you are not allowed to change miles&quot;) } def drive(dist) { if (dist&gt;0) miles += dist} } def car = new Car2(2012) println “Year: $car.year”println “Miles: $car.miles”println ‘Driving’car.drive(10)println “Can I set the year”println “Miles: $car.miles” try { println “Can I set the year?” car.year = 1900} catch (groovy.lang.ReadOnlyPropertyException ex){ println ex.message} try{ println “Can I set the miles?” car.miles = 12} catch (IllegalAccessException ex){ println(ex.message)}]]></content>
  </entry>
  <entry>
    <title><![CDATA[HashMap中计算hash值是如何实现的]]></title>
    <url>%2F2017%2F06%2F21%2FHashMap%E4%B8%AD%E8%AE%A1%E7%AE%97hash%E5%80%BC%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%2F</url>
    <content type="text"><![CDATA[以下摘自jdk1.7 /** * Retrieve object hash code and applies a supplemental hash function to the * result hash, which defends against poor quality hash functions. This is * critical because HashMap uses power-of-two length hash tables, that * otherwise encounter collisions for hashCodes that do not differ * in lower bits. Note: Null keys always map to hash 0, thus index 0. */ final int hash(Object k) { int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[groovy安全导航符]]></title>
    <url>%2F2017%2F06%2F16%2Fgroovy%E5%AE%89%E5%85%A8%E5%AF%BC%E8%88%AA%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[groovy提供了?. 安全导航操作符来简化对空指针的处理,避免抛出空指针异常,以达到减少噪音,节省开发者精力的目的 示例代码def foo(str){ //if (str != null) {str.reverse()} str?.reverse()}println foo(‘evil’)println foo(null) 输出结果:live null]]></content>
  </entry>
  <entry>
    <title><![CDATA[groovy循环]]></title>
    <url>%2F2017%2F06%2F13%2Fgroovy%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[groovy提供以下三种循环方法class WaysToLoop { void hello(){ 0.upto(2){println”$it”} println(“================”) 3.times { println(“$it”)} println(“================”) 0.step(10,2){ println(“$it”)} 3.times {print(‘ho’)} println ‘hello’ }}其中$it代表循环时的索引值]]></content>
  </entry>
  <entry>
    <title><![CDATA[外观设计模式]]></title>
    <url>%2F2017%2F06%2F12%2F%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[由于目前多个项目中大量使用外观设计模式,故对此设计模式做一总结外观模式（Facade），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。外观模式包含如下两个角色：(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql创建索引相关]]></title>
    <url>%2F2017%2F05%2F31%2Fmysql%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[PRIMARY KEY（主键索引）ALTER TABLE table_name ADD PRIMARY KEY (column_name)UNIQUE(唯一索引)ALTER TABLE table_name ADD UNIQUE (column_name)INDEX(普通索引)ALTER TABLE table_name ADD INDEX index_name (column_name)多列索引,列值的组合必须唯一ALTER TABLE table_name ADD INDEX index_name (column1_name,column2_name,column3_name)查看索引SHOW INDEX FROM table_name我们需要为以前的表 创建这个索引,有可能以前的数据中存在重复的记录 那怎么办呢?alter ignore table table_name add unique index index_name(column1_name,column2_name);它会删除重复的记录（别怕，会保留一条），然后建立唯一索引，高效而且人性化.]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2017%2F05%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好,欢迎来到我的个人技术博客!]]></content>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>